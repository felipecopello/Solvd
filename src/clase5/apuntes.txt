CLASES ABSTRACTAS 				VS 				INTERFACES:
- la clase es un obj o entidad						-la diferencia PRINCIPAL es que interface es una accion, si quiero construir mi jerarquia en vas a acciones
-Plane 										-IFly, TODOS los objetos que puedan volar
											-TODAS las interfaces en java tienen su propia convencion para los nombres IFly o Fly_able
-aca podemos elegir la privacidad 			-por default aca TODO es public final static, TODOS LOS CAMPOS FINAL VAN EN MAYUSCULA, asique en interface todos asi

1-entity /action
Hay clases finales en java, NO son heredables, ej String.
2-field
STATIC: si creamos un metodo o campo static, se inicializan automaticamente, no hace falta crear un objeto para acceder a ellos, clase.campo
y accedo. puedo modificar el campo sin inicializar un objeto. SI lo loopeo de esta manera para establecerle un valor al campo, el valor 
que le queda al campo de la clase es el ULTIMO. DE METODOS esttaticos se acceden a campos y metodos estaticos.

3-constructor
-ni abtractas ni interfaces inicializan objetos
-THE MAIN IDEA OF CONSTRUCTORS IS TO INICIALICE FIELDS, por lo que las clases abstractas deberian tener constructor. en las interfaces, como
son estaticos y finales, deberiamos darles un valor inicial inmediatamente, como son estaticos se INICIALIZAN SOLOS

en cuanto a los metodos:
4-methods
si yo quiero un metodo abstracto en una clase abstracta lo tengo que aclarar, en una interface son abstractos POR DEFAULT

5-methods
al crear una clase hija que extiende de una clase abstracta, puedo overrite los metods de padre. LA DIFERENCIA ES que puedo extender 
una sola clase a la hija, PERO con las interfaces puedo extenderle a una clase todas las interfaces que quiera

6-implementation
al elejir hay que pensar que es lo que tenemos que hacer, si la actividad es VOLAR usamos Ifly, SI lo que hacemos es manejar el aeropuerto
usamos objetos

para que usamos las interfaces? EJEMPLO DE cambio en la base de datos que usamos, y como podemos cambiar los metodos para una y otra.
voy a tener una sola interface y clases para cada base de datos, que heredan estos metodos y los sobreescribimos

POLYMORFISM:
Ej: tenemos una interface Ifly, y dos clases plane y bird que extienden la clase ifly. en el main de mi clase yo puedo inicializar un objeto
llamando a la interface IFly f = new Bird(); y luego llamar a f.fly() eso llama al metodo bird fly. para llamar al metodo plane fly puedo
hacer lo mismo, y lo llamo de la misma manera. HACIENDO ESTO solo podemos llamar asi a los metodos que esten tanto en la interface como en
las clases que la heredan. TENEMOS una definicion del metodo en la interface, dos REALIZACIONES en las clases y JAVA
decide a que realizacion llamar, basada en el objeto que uso

podemos BUSCAR con la interface Ifly los objetos que la utilicen.

class AirDef{
	public IFly findsmth(){
	return
	}
}
en este ejemplo no tenemos claro que estamos buscando, y usamos el polymorfismo para buscar